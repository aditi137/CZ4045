You can generate the truth table using a powerset,
def power_set(items):
    n = len(items)
    for i in xrange(2**n):
        combo = []
        for j in xrange(n):
            if (i >> j) % 2 == 1:
                combo.append(1)
            else:
                combo.append(0)
        yield combo    # if you want tuples, change to yield tuple(combo)


In [13]: list(power_set(l))
Out[13]: [[0, 0], [1, 0], [0, 1], [1, 1]]

In [14]: l=['B','C','E']

In [15]: list(power_set(l))
Out[15]: 
[[0, 0, 0],
[1, 0, 0],
 [0, 1, 0],
 [1, 1, 0],
 [0, 0, 1],
 [1, 0, 1],
 [0, 1, 1],
 [1, 1, 1]]

If you want to  make a dict of the data, change yield combo to yield tuple(combo)
Then you can store key value pairings  like:
d={}
for data in power_set(l):
    d[data]="your_calc_prob"
print d
{(0, 1): 'your_calc_prob', (1, 0): 'your_calc_prob', (0, 0): 'your_calc_prob', (1, 1): 'your_calc_prob'}

If you want the output sorted you can use sorted() which makes a copy of the list and returns a list:
 sorted(list(power_set(l)))
 Out[21]: 
 [[0, 0, 0],
 [0, 0, 1],
 [0, 1, 0],
 [0, 1, 1],
 [1, 0, 0],
 [1, 0, 1],
 [1, 1, 0],
 [1, 1, 1]]

Or you can use the list method sort() which sorts the list  in place:
In [22]: data = list(power_set(l))  
In [23]: data.sort()
In [24]: data
Out[24]: 
[[0, 0, 0],
[0, 0, 1],
[0, 1, 0],
[0, 1, 1],
[1, 0, 0],
[1, 0, 1],
[1, 1, 0],
[1, 1, 1]]


