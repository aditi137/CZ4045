Not
exactly
.
While
it
is
true
that
the
globals
are
shallow
copied
","
what
you
are
actually
seeing
is
the
scoping
of
globals
(
using
the
keyword
global
)
and
how
it
actually
operates
at
the
module
level
in
Python
.
You
can
observe
this
by
putting
in
a
pdb.set_trace()
inside
function
f
right
after
the
assignment
(
X
=
2
)
.
Yes
","
the
value
is
indeed
2
within
the
scope
of
f
","
but
let's
take
a
look
of
its
globals
.
Let's
look
at
how
they
compare
in
the
current
frame
and
up
a
frame
.
Ah
ha
","
you
can
see
that
they
are
NOT
actually
the
same
thing
","
and
that
X
is
indeed
1
and
has
not
been
changed
","
because
the
globals
there
are
within
the
<
doctest
doc.f
>
module
created
by
doctest
for
this
reason
.
Let's
continue
.
So
what
you
actually
saw
is
that
the
globals
within
the
doctest
is
not
the
same
one
as
the
one
on
your
source
(
hence
g
will
return
2
because
X
was
really
was
changed
in
the
module
here
by
f
","
but
not
in
the
doctest
module
shallow
copy
scope
)
","
even
though
it
originally
was
copied
from
the
module
but
the
changes
are
not
reflected
back
to
the
underlying
module
since
this
is
how
the
global
keyword
operates
-
at
the
module
level
","
not
across
modules
.
