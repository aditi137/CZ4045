You
need
more
abstraction
.
Don't
hard-code
the
file
path
in
printfile.py
Don't
access
a
global
in
the
printf
function
.
Do
accept
a
file
handle
as
a
parameter
to
the
printf
function
:
In
a
script
that
does
actually
need
to
know
the
path
of
f.txt
(
I
guess
helloworld.py
in
your
case
)
","
put
it
there
","
open
it
","
and
pass
it
to
printf
:
Better
yet
","
get
the
file
path
from
the
command
line
EDIT
:
You
said
on
your
Google
+
cross-post
:
full
path
is
problem
","
the
program
will
run
on
differents
environments
.
If
you're
trying
to
distribute
your
program
to
other
users
and
machines
","
you
should
look
into
making
a
distribution
package
(
see
side
note
3
below
)
","
and
using
package_data
to
include
your
configuration
file
","
and
pkgutil
or
pkg_resources
to
access
the
configuration
file
.
See
How
do
I
use
data
in
package_data
from
source
code
?
Some
side-notes
:
Represent
directories
as
the
directory
name
with
a
trailing
slash
","
Ãƒ
la
the
conventions
of
the
tree
command
:
/
instead
of
<
root
>
","
moduleOne
/
instead
of
<
moduleOne
>
You're
conflating
""""
module
""""
with
""""
package
""""
.
I
suggest
you
rename
moduleOne
/
to
packageOne
/
.
A
directory
with
an
__init__.py
file
constitutes
a
package
.
A
file
ending
in
a
.
py
extension
is
a
module
.
Modules
can
be
part
of
packages
by
physically
existing
inside
a
directory
with
an
__init__.py
file
.
Packages
can
be
part
of
other
packages
by
being
a
physical
subdirectory
of
a
parent
directory
with
an
__init__.py
file
.
Unfortunately
","
the
term
""""
package
""""
is
overloaded
in
Python
and
also
can
mean
a
collection
of
Python
code
for
distribution
and
installation
.
See
the
Python
Packaging
Guide
glossary
.
