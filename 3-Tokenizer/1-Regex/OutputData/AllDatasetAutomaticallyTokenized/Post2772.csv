The
reason
you
see
only
the
first
character
is
that
by
calling
c_char()
you
create
a
single
char
value
that
Python
treats
like
a
str
(
Python
2
)
object
or
bytes
(
Python
3
)
object
of
length
1
.
You
are
probably
lucky
that
you
do
not
get
a
segmentation
fault
.
By
writing
more
than
1
byte
or
a
NULL-terminated
string
of
length
>
0
(
e.g
.
with
strcpy
)
in
the
C
code
","
you
actually
produce
an
undetected
buffer
overflow
.
ctypes
does
not
know
how
many
bytes
you
have
written
at
the
pointer's
memory
location
.
path.value
is
still
a
str
/
bytes
of
length
1
.
It
would
be
better
to
change
the
C
pathinfo
function
into
someting
like
Use
ctypes.create_string_buffer()
to
allocate
memory
in
your
Python
code
and
let
pathinfo
return
the
length
of
the
result
.
Of
course
you
have
to
check
","
whether
char
*
path
is
large
enough
using
bsize
in
your
C-Code
.
The
Python-code
would
look
like
this
:
Also
be
aware
of
NULL-termination
in
the
C
domain
","
character
encodings
when
converting
python
strings
to
char
*
and
back
","
the
changes
regarding
str
/
bytes
in
ctypes
regarding
Python
2
and
Python
3
.
