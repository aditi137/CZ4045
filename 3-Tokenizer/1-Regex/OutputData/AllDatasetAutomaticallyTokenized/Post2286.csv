Your
diagnosis
appears
to
be
flawed
.
Using
the
timeit
module
you'll
find
that
using
addional
locals
is
in
fact
slower
","
but
only
by
the
smallest
of
margins
.
I
reduced
your
tests
to
the
essentials
to
reduce
overhead
:
The
difference
is
so
small
as
to
be
negligible
.
If
you
run
this
often
enough
f2
can
win
by
the
same
margin
.
If
you
reverse
the
tests
(
run
f2
first
","
then
f1
)
","
the
outcomes
change
again
.
That's
because
there
is
practically
no
difference
.
The
two
functions
execute
the
exact
same
bytecodes
","
with
the
addition
of
two
STORE_FAST
and
LOAD_FAST
opcodes
for
f2
at
indices
22
","
47
","
50
and
53
.
The
STORE_FAST
and
LOAD_FAST
copy
across
a
pointer
between
the
stack
and
the
locals
array
","
both
pre-allocated
structures
.
So
f2
is
doing
the
teensiest
more
work
than
f1
is
doing
.
Changing
the
sizes
of
the
inputs
is
not
making
a
difference
here
","
a
pointer
doesn't
get
'
heavier
'
if
the
referenced
object
is
bigger
.
