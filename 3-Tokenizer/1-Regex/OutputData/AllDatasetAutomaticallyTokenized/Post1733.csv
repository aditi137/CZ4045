I
don't
have
enough
experience
with
the
gdb
Python
api
to
call
this
an
answer
;
I
consider
this
just
some
research
notes
from
a
fellow
developer
.
My
code
attached
below
is
quite
crude
and
ugly
","
too
.
However
","
this
does
work
with
gdb-7.4
and
python-2.7.3
.
An
example
debugging
run
:
All
of
the
above
are
bog-standard
pretty-printed
outputs
-
-
my
reasoning
is
that
I
often
want
to
see
what
the
pointers
are
","
so
I
didn't
want
to
override
those
.
However
","
dreferencing
the
pointers
uses
the
prettyprinter
shown
further
below
:
The
last
line
shows
that
when
debugging
tiny
","
tiny-gdb.py
in
the
same
directory
gets
loaded
automatically
(
although
you
can
disable
this
","
I
do
believe
this
is
the
default
behaviour
)
.
The
tiny-gdb.py
file
used
for
above
:
The
reasoning
behind
my
choices
are
as
follows
:
How
to
install
pretty-printers
to
gdb
?
There
are
two
parts
to
this
question
:
where
to
install
the
Python
files
","
and
how
to
hook
the
pretty-printers
to
gdb
.
Because
the
pretty-printer
selection
cannot
rely
on
the
inferred
type
alone
","
but
has
to
peek
into
the
actual
data
fields
","
you
cannot
use
the
regular
expression
matching
functions
.
Instead
","
I
chose
to
add
my
own
pretty-printer
selector
function
","
typefilter()
","
to
the
global
pretty-printers
list
","
as
described
in
the
documentation
.
I
did
not
implement
the
enable
/
disable
functionality
","
because
I
believe
it
is
easier
to
just
load
/
not
load
the
relevant
Python
script
instead
.
(
typefilter()
gets
called
once
per
every
variable
reference
","
unless
some
other
pretty-printer
has
already
accepted
it
.
)
The
file
location
issue
is
a
more
complicated
one
.
For
application-specific
pretty-printers
","
putting
them
into
a
single
Python
script
file
sounds
sensible
","
but
for
a
library
","
some
splitting
seems
to
be
in
order
.
The
documentation
recommends
packaging
the
functions
into
a
Python
module
","
so
that
a
simple
python
import module
enables
the
pretty-printer
.
Fortunately
","
Python
packaging
is
quite
straightforward
.
If
you
were
to
import gdb
to
the
top
and
save
it
to
/
usr
/
lib
/
pythonX.Y
/
tiny.py
","
where
X.Y
is
the
python
version
used
","
you
only
need
to
run
python
import tiny
in
gdb
to
enable
the
pretty-printer
.
Of
course
","
properly
packaging
the
pretty-printer
is
a
very
good
idea
","
especially
if
you
intend
to
distribute
it
","
but
it
does
pretty
much
boil
down
to
adding
some
variables
et
cetera
to
the
beginning
of
the
script
","
assuming
you
keep
it
as
a
single
file
.
For
more
complex
pretty-printers
","
using
a
directory
layout
might
be
a
good
idea
.
If
you
have
a
value
val
","
then
val.type
is
the
gdb.Type
object
describing
its
type
;
converting
it
to
string
yields
a
human-readable
type
name
.
val.type.strip_typedefs()
yields
the
actual
type
with
all
typedefs
stripped
.
I
even
added
.
unqualified()
","
so
that
all
const
/
volatile
/
etc.
type
qualifiers
are
removed
.
NULL
pointer
detection
is
a
bit
tricky
.
The
best
way
I
found
","
was
to
examine
the
stringified
.
address
member
of
the
target
gdb.Value
object
","
and
see
if
it
is
""""
0x0
""""
.
To
make
life
easier
","
I
was
able
to
write
a
simple
deref()
function
","
which
tries
to
dereference
a
pointer
.
If
the
target
points
to
(
void
*
)
0
","
it
returns
the
string
""""
NULL
""""
","
otherwise
it
returns
the
target
gdb.Value
object
.
The
way
I
use
deref()
is
based
on
the
fact
that
""""
array
""""
type
pretty-printers
yield
a
list
of
2-tuples
","
where
the
first
item
is
the
name
string
","
and
the
second
item
is
either
a
gdb.Value
object
","
or
a
string
.
This
list
is
returned
by
the
children()
method
of
the
pretty-printer
object
.
Handling
""""
discriminated
union
""""
types
would
be
much
easier
","
if
you
had
a
separate
type
for
the
generic
entity
.
That
is
","
if
you
had
and
it
was
used
everywhere
when
the
tag
value
is
still
uncertain
;
and
the
specific
structure
types
only
used
where
their
tag
value
is
fixed
.
This
would
allow
a
much
simpler
type
inference
.
As
it
is
","
in
tiny.c
the
struct
box*_st
types
can
be
used
interchangeably
.
(
Or
","
more
specifically
","
we
cannot
rely
on
a
specific
tag
value
based
on
the
type
alone
.
)
The
sequence
case
is
actually
quite
simple
","
because
valtab
[]
can
be
treated
as
simply
as
an
array
of
void
pointers
.
The
sequence
tag
is
used
to
pick
the
correct
union
member
.
In
fact
","
if
valtab
[]
was
simply
a
void
pointer
array
","
then
gdb.Value.cast(gdb.lookup_type()
)
or
gdb.Value.reinterpret_cast(gdb.lookup_type()
)
can
be
used
to
change
each
pointer
type
as
necessary
","
just
like
I
do
for
the
boxed
structure
types
.
Recursion
limits
?
You
can
use
the
@
operator
in
print
command
to
specify
how
many
elements
are
printed
","
but
that
does
not
help
with
nesting
.
If
you
add
iseq3->valtab
[2]
=
(
myval_t)iseq3
;
to
tiny.c
","
you
get
an
infinitely
recursive
sequence
.
gdb
does
print
it
nicely
","
especially
with
set
print
array
","
but
it
does
not
notice
or
care
about
the
recursion
.
In
my
opinion
","
you
might
wish
to
write
a
gdb
command
in
addition
to
a
pretty-printer
for
deeply
nested
or
recursive
data
structures
.
During
my
testing
","
I
wrote
a
command
that
uses
Graphviz
to
draw
binary
tree
structures
directly
from
within
gdb
;
I'm
absolutely
convinced
it
beats
plain
text
output
.
Added
:
If
you
save
the
following
as
/
usr
/
lib
/
pythonX.Y
/
tree.py
:
you
can
use
it
in
gdb
:
If
you
have
e.g
.
and
you
have
X11
(
local
or
remote
)
connection
and
Graphviz
installed
","
you
can
use
to
view
the
tree
structure
.
Because
it
retains
a
list
of
already
visited
nodes
(
as
a
Python
set
)
","
it
does
not
get
fazed
about
recursive
structures
.
I
probably
should
have
cleaned
my
Python
snippets
before
posting
","
but
no
matter
.
Please
do
consider
these
only
initial
testing
versions
;
use
at
your
own
risk
.
:
)
