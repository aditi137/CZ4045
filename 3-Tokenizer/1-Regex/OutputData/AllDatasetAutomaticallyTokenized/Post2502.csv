I'll
need
to
read
your
post
in
more
detail
","
but
will
start
with
some
general
observations
(
from
previous
iteration
questions
)
.
There
isn't
an
efficient
way
of
iterating
over
arrays
in
Python
","
though
there
are
things
that
slow
things
down
.
I
like
to
distinguish
between
the
iteration
mechanism
(
nditer
","
for
x
in
A
:
)
and
the
action
(
alist.append(...)
","
x
[
i+1
]
+
=
1
)
.
The
big
time
consumer
is
usually
the
action
","
done
many
times
","
not
the
iteration
mechanism
itself
.
Letting
numpy
do
the
iteration
in
compiled
code
is
the
fastest
.
is
much
faster
than
The
np.nditer
isn't
any
faster
.
nditer
is
recommended
as
a
general
iteration
tool
in
compiled
code
.
But
its
main
value
lies
in
handling
broadcasting
and
coordinating
the
iteration
over
several
arrays
(
input
/
output
)
.
And
you
need
to
use
buffering
and
c
like
code
to
get
the
best
speed
from
nditer
(
I'll
look
up
a
recent
SO
question
)
.
https://stackoverflow.com/a/39058906/901925
Don't
use
nditer
without
studying
the
relevant
iteration
tutorial
page
(
the
one
that
ends
with
a
cython
example
)
.
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
Just
judging
from
experience
","
this
approach
will
be
fastest
.
Yes
it's
going
to
iterate
over
secaxis
a
number
of
times
","
but
those
are
all
done
in
compiled
code
","
and
will
be
much
faster
than
any
iteration
in
Python
.
And
the
for
f
in
X
:
iteration
is
just
a
few
times
.
@HYRY
has
explored
alternatives
for
making
the
where
step
faster
.
But
as
you
can
see
the
differences
aren't
that
big
.
Other
possible
tweaks
If
X
was
an
array
","
res
could
be
an
array
as
well
.
But
for
small
N
I
suspect
the
list
res
is
just
as
good
.
Don't
need
to
make
the
arrays
any
bigger
than
necessary
.
The
tweaks
are
minor
","
just
trying
to
avoid
recalculating
things
.
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
This
use
of
np.where
is
just
np.nonzero
.
That
actually
makes
two
passes
of
the
array
","
once
with
np.count_nonzero
to
determine
how
many
values
it
will
return
","
and
create
the
return
structure
(
list
of
arrays
of
now
known
length
)
.
And
a
second
loop
to
fill
in
those
indices
.
So
multiple
iterations
are
fine
if
it
keeps
action
simple
.
