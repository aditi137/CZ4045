The
answer
you
gave
me
is
great
and
extract
perfectly
the
pixel
information
(
changing
uint8
to
uint16
)
.
However
","
the
values
I
obtain
are
higher
than
the
real
ones
.
There
is
an
offset
and
because
of
the
LOSSY
compression
in
JPEG2000
there
is
a
little
error
of
1
or
2
in
the
value
.
I
don't
like
to
use
external
calls
but
in
this
case
I
found
this
as
a
better
and
faster
solution
:
I
downloaded
Kakadu
(
free
software
for
non
commercial
purposes
)
and
I
use
the
module
kdu_expand
.
os.system('kdu_expand -i image.jp2 -o temp_image.tif')
im=PIL.Image.open('temp_image.tif
'
)
pixels=array(im.getdata()).reshape((im.size
[0]
","
im.size
[1]
)
)
I
convert
the
image
from
JPEG2000
to
TIF
but
it
is
quick
and
the
static
memory
is
not
usually
a
limitation
(
nowadays
)
in
a
computer
.
Then
","
the
PIL
library
perfectly
manages
to
extarct
the
data
.
Note
:
I
tried
the
conversion
straight
with
PythonMagick
but
it
gives
me
the
same
offset
as
before
Note
2
:
I
found
another
interesting
library
in
OpenCV
but
the
result
is
incorrect
pixels_cv2=cv2.imread('image.jp2
'
","
0
)
Note3
:
The
images
I
used
are
satellite
images
codified
with
12
bites
.
Possibly
in
other
type
of
data
the
PythonMagick
behaves
better
.
