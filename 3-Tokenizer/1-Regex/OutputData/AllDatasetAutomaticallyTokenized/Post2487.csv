Multiple
inheritance
in
Python
requires
that
all
the
classes
cooperate
to
make
it
work
.
In
this
case
","
you
can
make
them
cooperate
by
having
the
__init__
method
in
each
class
accept
arbitrary
*
*
kwargs
and
pass
them
on
when
they
call
super()
.
__init__
.
For
your
example
class
hierarchy
","
you
could
do
something
like
this
:
Note
that
if
you
wanted
D
to
use
the
argument
values
directly
(
rather
than
using
self.a
","
etc.
)
","
you
could
both
take
them
as
named
arguments
and
still
pass
them
on
in
the
super()
call
:
Accepting
and
passing
on
some
args
is
important
if
some
of
the
parent
classes
don't
save
the
arguments
(
in
their
original
form
)
as
attributes
","
but
you
need
those
values
.
You
can
also
use
this
style
of
code
to
pass
on
modified
values
for
some
of
the
arguments
(
e.g
.
with
"super(D, self)"
.
"__init__(a=a, b=b, c1=2*c1, c2=5*c2, **kwargs)"
)
.
This
kind
of
collaborative
multiple
inheritance
with
varying
arguments
is
almost
impossible
to
make
work
using
positional
arguments
.
With
keyword
arguments
though
","
the
order
of
the
names
and
values
in
a
call
doesn't
matter
","
so
it's
easy
to
pass
on
named
arguments
and
*
*
kwargs
at
the
same
time
without
anything
breaking
.
Using
*
args
doesn't
work
as
well
(
though
recent
versions
of
Python
3
are
more
flexible
about
how
you
can
call
functions
with
*
args
","
such
as
allowing
multiple
unpackings
in
a
single
call
:
"f(*foo, bar, *baz)"
)
.
If
you
were
using
Python
3
(
I'm
assuming
not
","
since
you're
explicitly
passing
arguments
to
super
)
","
you
could
make
the
arguments
to
your
collaborative
functions
""""
keyword-only
""""
","
which
would
prevent
users
from
getting
very
mixed
up
and
trying
to
call
your
methods
with
positional
arguments
.
Just
put
a
bare
*
in
the
argument
list
before
the
other
named
arguments
:
"def __init__(self, *, c1, c2, **kwargs):"
.
