Armin's
suggestion
of
the
array
module
is
probably
best
.
Two
possible
alternatives
:
You
can
create
an
extension
module
yourself
that
provides
the
data
structure
that
you're
after
.
If
it's
really
just
something
like
a
collection
of
shorts
","
then
that's
pretty
simple
to
do
.
You
can
cheat
and
manipulate
bits
","
so
that
you're
storing
one
number
in
the
lower
half
of
the
Python
int
","
and
another
one
in
the
upper
half
.
You'd
write
some
utility
functions
to
convert
to
/
from
these
within
your
data
structure
.
Ugly
","
but
it
can
be
made
to
work
.
It's
also
worth
realising
that
a
Python
integer
object
is
not
4
bytes
-
there
is
additional
overhead
.
So
if
you
have
a
really
large
number
of
shorts
","
then
you
can
save
more
than
two
bytes
per
number
by
using
a
C
short
in
some
way
(
e.g
.
the
array
module
)
.
I
had
to
keep
a
large
set
of
integers
in
memory
a
while
ago
","
and
a
dictionary
with
integer
keys
and
values
was
too
large
(
I
had
1GB
available
for
the
data
structure
IIRC
)
.
I
switched
to
using
a
IIBTree
(
from
ZODB
)
and
managed
to
fit
it
.
(
The
ints
in
a
IIBTree
are
real
C
ints
","
not
Python
integers
","
and
I
hacked
up
an
automatic
switch
to
a
IOBTree
when
the
number
was
larger
than
32
bits
)
.
