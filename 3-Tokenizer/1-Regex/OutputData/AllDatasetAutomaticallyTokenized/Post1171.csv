The
cleanest
solution
would
be
inotify
in
many
ways
-
this
is
more
or
less
exactly
what
it's
intended
for
","
after
all
.
If
the
log
file
was
changing
extremely
rapidly
then
you
could
potentially
risk
being
woken
up
almost
constantly
","
which
wouldn't
necessarily
be
particularly
efficient
-
however
","
you
could
always
mitigate
this
by
adding
a
short
delay
of
your
own
after
the
inotify
filehandle
returns
an
event
.
In
practice
I
doubt
this
would
be
an
issue
on
most
systems
","
but
I
thought
it
worth
mentioning
in
case
your
system
is
very
tight
on
CPU
resources
.
I
can't
see
how
the
sleep()
approach
would
miss
file
updates
except
in
cases
where
the
file
is
truncated
or
rotated
(
i.e.
renamed
and
another
file
of
the
same
name
created
)
.
These
are
tricky
cases
to
handle
however
you
do
things
","
and
you
can
use
tricks
like
periodically
re-opening
the
file
by
name
to
check
for
rotation
.
Read
the
tail
man
page
because
it
handles
many
such
cases
","
and
they're
going
to
be
quite
common
for
log
files
in
particular
(
log
rotation
being
widely
considered
to
be
good
practice
)
.
The
downside
of
sleep()
is
of
course
that
you'd
end
up
batching
up
your
reads
with
delays
in
between
","
and
also
that
you
have
the
overhead
of
constantly
waking
up
and
polling
the
file
even
when
it's
not
changing
.
If
you
did
this
","
say
","
once
per
second
","
however
","
the
overhead
probably
isn't
noticeable
on
most
systems
.
I'd
say
inotify
is
the
best
choice
unless
you
want
to
remain
compatible
","
in
which
case
the
simple
fallback
using
sleep()
is
still
quite
reasonable
.
EDIT
:
I
just
realised
I
forgot
to
mention
-
an
easy
way
to
check
for
a
file
being
renamed
is
to
perform
an
os.fstat(fd.fileno()
)
on
your
open
filehandle
and
a
os.stat()
on
the
filename
you
opened
and
compare
the
results
.
If
the
os.stat()
fails
then
the
error
will
tell
you
if
the
file's
been
deleted
","
and
if
not
then
comparing
the
st_ino
(
the
inode
number
)
fields
will
tell
you
if
the
file's
been
deleted
and
then
replaced
with
a
new
one
of
the
same
name
.
Detecting
truncation
is
harder
-
effectively
your
read
pointer
remains
at
the
same
offset
in
the
file
and
reading
will
return
nothing
until
the
file
content
size
gets
back
to
where
you
were
-
then
the
file
will
read
from
that
point
as
normal
.
If
you
call
os.stat()
frequently
you
could
check
for
the
file
size
going
backwards
-
alternatively
you
could
use
fd.tell()
to
record
your
current
position
in
the
file
and
then
perform
an
explicit
seek
to
the
end
of
the
file
and
call
fd.tell()
again
.
If
the
value
is
lower
","
then
the
file's
been
truncated
under
you
.
This
is
a
safe
operation
as
long
as
you
keep
the
original
file
position
around
because
you
can
always
seek
back
to
it
after
the
check
.
Alternatively
if
you're
using
inotify
anyway
","
you
could
just
watch
the
parent
directory
for
changes
.
Note
that
files
can
be
truncated
to
non-zero
sizes
","
but
I
doubt
that's
likely
to
happen
to
a
log
file
-
the
common
cases
will
be
being
deleted
and
replaced
","
or
truncated
to
zero
.
Also
","
I
don't
know
how
you'd
detect
the
case
that
the
file
was
truncated
and
then
immediately
filled
back
up
to
beyond
your
current
position
","
except
by
remembering
the
most
recent
N
characters
and
comparing
them
","
but
that's
a
pretty
grotty
thing
to
do
.
I
think
inotify
will
just
tell
you
the
file
has
been
modified
in
that
case
.
