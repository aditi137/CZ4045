It
works
out
better
than
you'd
believe
.
Recently
I
did
a
large
reverse-engineering
job
on
a
hideous
old
collection
of
C
code
.
Function
by
function
I
reallocated
the
features
that
were
still
relevant
into
classes
","
wrote
unit
tests
for
the
classes
","
and
built
up
what
looked
like
a
replacement
application
.
It
had
some
of
the
original
""""
logic
flow
""""
through
the
classes
","
and
some
classes
were
poorly
designed
[
Mostly
this
was
because
of
a
subset
of
the
global
variables
that
was
too
hard
to
tease
apart
.
]
It
passed
unit
tests
at
the
class
level
and
at
the
overall
application
level
.
The
legacy
source
was
mostly
used
as
a
kind
of
""""
specification
in
C
""""
to
ferret
out
the
really
obscure
business
rules
.
Last
year
","
I
wrote
a
project
plan
for
replacing
30-year
old
COBOL
.
The
customer
was
leaning
toward
Java
.
I
prototyped
the
revised
data
model
in
Python
using
Django
as
part
of
the
planning
effort
.
I
could
demo
the
core
transactions
before
I
was
done
planning
.
Note
:
It
was
quicker
to
build
a
the
model
and
admin
interface
in
Django
than
to
plan
the
project
as
a
whole
.
Because
of
the
""""
we
need
to
use
Java
""""
mentality
","
the
resulting
project
will
be
larger
and
more
expensive
than
finishing
the
Django
demo
.
With
no
real
value
to
balance
that
cost
.
Also
","
I
did
the
same
basic
""""
prototype
in
Django
""""
for
a
VB
desktop
application
that
needed
to
become
a
web
application
.
I
built
the
model
in
Django
","
loaded
legacy
data
","
and
was
up
and
running
in
a
few
weeks
.
I
used
that
working
prototype
to
specify
the
rest
of
the
conversion
effort
.
Note
:
I
had
a
working
Django
implementation
(
model
and
admin
pages
only
)
that
I
used
to
plan
the
rest
of
the
effort
.
The
best
part
about
doing
this
kind
of
prototyping
in
Django
is
that
you
can
mess
around
with
the
model
","
unit
tests
and
admin
pages
until
you
get
it
right
.
Once
the
model's
right
","
you
can
spend
the
rest
of
your
time
fiddling
around
with
the
user
interface
until
everyone's
happy
.
