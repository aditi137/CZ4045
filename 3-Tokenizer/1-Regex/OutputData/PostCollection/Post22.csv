,0
0,what
1,is
2,a
3,"""Unicode"
4,string
5,""""
6,in
7,Python
8,?
9,Does
10,that
11,mean
12,UCS
13,-2?
14,Unicode
15,strings
16,in
17,Python
18,are
19,stored
20,internally
21,either
22,as
23,UCS
24,-2
25,(fixed-length
26,16
27,-bit
28,representation
29,","
30,almost
31,the
32,same
33,as
34,UTF
35,-16)
36,or
37,UCS
38,-4/UTF-32
39,(fixed-length
40,32
41,-bit
42,representation
43,).
44,It
45,'s
46,a
47,compile
48,-time
49,option
50,;
51,on
52,Windows
53,it
54,'s
55,always
56,UTF
57,-16
58,whilst
59,many
60,Linux
61,distributions
62,set
63,UTF
64,-32
65,(‘wide
66,mode
67,’)
68,for
69,their
70,versions
71,of
72,Python
73,.
74,You
75,are
76,generally
77,not
78,supposed
79,to
80,"care: you will see Unicode code-points as single elements in your strings and you won't know whether they're stored as two or four bytes. If you're in a UTF-16 build and you need to handle characters outside the Basic Multilingual Plane you'll be Doing It Wrong, but that's still very rare, and users who really need the extra characters should be compiling wide builds.
plain wrong, or is it?
Yes, it's quite wrong. To be fair I think that tutorial is rather old; it probably pre-dates wide Unicode strings, if not Unicode 3.1 (the version that introduced characters outside the Basic Multilingual Plane)"
81,.
82,There
83,is
84,an
85,additional
86,source
87,of
88,confusion
89,stemming
90,from
91,Windows
92,'s
93,habit
94,of
95,using
96,the
97,term
98,“Unicode”
99,to
100,mean
101,","
102,specifically
103,","
104,the
105,UTF
106,-16LE
107,encoding
108,that
109,NT
110,uses
111,internally
112,.
113,People
114,from
115,Microsoftland
116,may
117,often
118,copy
119,this
120,somewhat
121,misleading
122,habit
123,.
