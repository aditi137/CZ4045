,0
0,Armin
1,'s
2,suggestion
3,of
4,the
5,array
6,module
7,is
8,probably
9,best
10,.
11,Two
12,possible
13,"alternatives:
You can create an extension module yourself that provides the data structure that you're after.  If it's really just something like a collection of shorts, then
that's pretty simple to do.
You can
cheat and manipulate bits, so that
you're storing one number in the
lower half of the Python int, and
another one in the upper half. 
You'd write some utility functions
to convert to/from these within your
data structure.  Ugly, but it can be made to work.
It's also worth realising that a Python integer object is not 4 bytes - there is additional overhead.  So if you have a really large number of shorts, then you can save more than two bytes per number by using a C short in some way (e.g. the array module)"
14,.
15,I
16,had
17,to
18,keep
19,a
20,large
21,set
22,of
23,integers
24,in
25,memory
26,a
27,while
28,ago
29,","
30,and
31,a
32,dictionary
33,with
34,integer
35,keys
36,and
37,values
38,was
39,too
40,large
41,(I
42,had
43,1GB
44,available
45,for
46,the
47,data
48,structure
49,IIRC
50,).
51,I
52,switched
53,to
54,using
55,a
56,IIBTree
57,(from
58,ZODB
59,)
60,and
61,managed
62,to
63,fit
64,it
65,.
66,(The
67,ints
68,in
69,a
70,IIBTree
71,are
72,real
73,C
74,ints
75,","
76,not
77,Python
78,integers
79,","
80,and
81,I
82,hacked
83,up
84,an
85,automatic
86,switch
87,to
88,a
89,IOBTree
90,when
91,the
92,number
93,was
94,larger
95,than
96,32
97,bits
98,).
