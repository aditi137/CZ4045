,0
0,I
1,'ve
2,read
3,a
4,lot
5,about
6,different
7,techniques
8,for
9,iterating
10,over
11,numpy
12,arrays
13,recently
14,and
15,it
16,seems
17,that
18,consensus
19,is
20,not
21,to
22,iterate
23,at
24,all
25,(for
26,instance
27,","
28,see
29,a
30,comment
31,here
32,).
33,There
34,are
35,several
36,similar
37,questions
38,on
39,SO
40,","
41,but
42,my
43,case
44,is
45,a
46,bit
47,different
48,as
49,I
50,have
51,to
52,combine
53,"""iterating"""
54,(or
55,not
56,iterating
57,)
58,and
59,accessing
60,previous
61,values
62,.
63,Let
64,'s
65,say
66,there
67,are
68,N
69,(N
70,is
71,small
72,","
73,usually
74,4
75,","
76,might
77,be
78,up
79,to
80,7
81,)
82,1
83,-D
84,numpy
85,arrays
86,of
87,float128
88,in
89,a
90,list
91,X
92,","
93,all
94,arrays
95,are
96,of
97,the
98,same
99,size
100,.
101,To
102,give
103,you
104,a
105,little
106,insight
107,","
108,these
109,are
110,data
111,from
112,PDE
113,integration
114,","
115,each
116,array
117,stands
118,for
119,one
120,function
121,","
122,and
123,I
124,would
125,like
126,to
127,apply
128,a
129,Poincare
130,section
131,.
132,Unfortunately
133,","
134,the
135,algorithm
136,should
137,be
138,both
139,memory
140,-
141,and
142,time
143,-efficient
144,since
145,these
146,arrays
147,are
148,sometimes
149,~1Gb
150,each
151,","
152,and
153,there
154,are
155,only
156,4Gb
157,of
158,RAM
159,on
160,board
161,(I've
162,just
163,learnt
164,about
165,memmap
166,'ing
167,of
168,numpy
169,arrays
170,and
171,now
172,consider
173,using
174,them
175,instead
176,of
177,regular
178,ones
179,).
180,One
181,of
182,these
183,arrays
184,is
185,used
186,for
187,"""filtering"""
188,the
189,others
190,","
191,so
192,I
193,start
194,with
195,secaxis = X
196,.pop(idx).
197,Now
198,I
199,have
200,to
201,locate
202,pairs
203,of
204,indices
205,where
206,(secaxis[i-1]
207,>
208,0
209,and
210,secaxis
211,[i]
212,<
213,0
214,)
215,or
216,(secaxis[i-1]
217,<
218,0
219,and
220,secaxis
221,[i]
222,>
223,0
224,)
225,and
226,then
227,apply
228,simple
229,algebraic
230,transformations
231,to
232,remaining
233,arrays
234,","
235,X
236,(and
237,save
238,results
239,).
240,Worth
241,mentioning
242,","
243,data
244,shouldn
245,'t
246,be
247,wasted
248,during
249,this
250,operation
251,.
252,There
253,are
254,multiple
255,ways
256,for
257,doing
258,that
259,","
260,but
261,none
262,of
263,them
264,seem
265,efficient
266,(and
267,elegant
268,enough
269,)
270,to
271,me
272,.
273,One
274,is
275,a
276,C
277,-like
278,approach
279,","
280,where
281,you
282,just
283,iterate
284,in
285,a
286,for
287,-loop:
288,This
289,is
290,clearly
291,very
292,inefficient
293,and
294,besides
295,not
296,a
297,Pythonic
298,way
299,.
300,Another
301,way
302,is
303,to
304,use
305,numpy
306,".nditer,"
307,but
308,I
309,haven
310,'t
311,figured
312,out
313,yet
314,how
315,one
316,accesses
317,the
318,previous
319,value
320,","
321,though
322,it
323,allows
324,iterating
325,over
326,several
327,arrays
328,at
329,"once:
Third possibility is to first find sought indices with efficient numpy slices, and then use them for bulk multiplication/addition. I prefer this one for now:
But this is seemingly done in 7 + 2*(N - 1)"
330,passes
331,","
332,moreover
333,","
334,I
335,'m
336,not
337,sure
338,about
339,secaxis
340,[inds]
341,type
342,of
343,addressing
344,(it
345,is
346,not
347,slicing
348,and
349,generally
350,it
351,has
352,to
353,find
354,all
355,elements
356,by
357,indices
358,just
359,like
360,in
361,the
362,first
363,method
364,","
365,doesn
366,'t
367,it
368,?).
369,Finally
370,","
371,I
372,'ve
373,also
374,tried
375,using
376,itertools
377,and
378,it
379,resulted
380,in
381,monstrous
382,and
383,obscure
384,structures
385,","
386,which
387,might
388,stem
389,from
390,the
391,fact
392,that
393,I
394,'m
395,not
396,very
397,familiar
398,with
399,functional
400,"programming:
Not only this looks very ugly, it also takes an awful lot of time to complete.
So, I have following questions:
Of all these methods is the third one indeed the best? If so, what can be done to impove the last one?
Are there any other, better ones yet? 
Out of sheer curiosity, is there a way to solve the problem using nditer?
Finally, will I be better off using memmap versions of numpy arrays, or will it probably slow things down a lot? Maybe I should only load secaxis array into RAM, keep others on disk and use third method?
(bonus question)"
401,List
402,of
403,equal
404,in
405,length
406,1
407,-D
408,numpy
409,arrays
410,comes
411,from
412,loading
413,N
414,.npy
415,files
416,whose
417,sizes
418,aren
419,'t
420,known
421,beforehand
422,(but
423,N
424,is
425,).
426,Would
427,it
428,be
429,more
430,efficient
431,to
432,read
433,one
434,array
435,","
436,then
437,allocate
438,memory
439,for
440,one
441,2
442,-D
443,numpy
444,array
445,(slight
446,memory
447,overhead
448,here
449,)
450,and
451,read
452,remaining
453,into
454,that
455,2
456,-D
457,array
458,?
