,0
0,Assignment
1,itself
2,does
3,nothing
4,.
5,rc
6,here
7,is
8,your
9,client
10,.
11,Doing
12,rc
13,[0]
14,","
15,or
16,any
17,sort
18,of
19,indexing
20,","
21,generates
22,and
23,returns
24,a
25,DirectView
26,object
27,that
28,'s
29,a
30,view
31,with
32,whatever
33,engines
34,you
35,specify
36,in
37,[]
38,.
39,This
40,is
41,a
42,shorthand
43,for
44,generating
45,the
46,"views: it's not actually just getting a specific object.
Thus, those views aren't unique. The best way to explain it, I think, is with an example. Say you have 2 engines. You want to run some tasks on only engine one, and want the tasks to block. You want to run others on only engine one, but don't want them to block. You want to run yet more on engines 1 and 2, and don't want them to block. Then you could do:
Then, you can use these to run tasks in whatever way you'd like, eg
There's no actual magic being used here. When you run rc[0] twice, it generates two views. The second view is not the same as the first. When you assign rc[0] to a variable, and then use that variable, you're working with one view, and not creating a new one. 
iPython, like Numpy and Scipy, has quite a few shorthand notations that don't necessarily fit Python's idioms perfectly. This is especially the case with [] and getitem. A purer Python way of writing this could would be to use the much more unwieldy rc.direct_view(1)"
47,","
48,and
49,so
50,on
51,","
52,which
53,would
54,make
55,clear
56,that
57,this
58,wasn
59,'t
60,just
61,getting
62,an
63,item
64,","
65,and
66,was
67,actually
68,creating
69,a
70,view
71,.
